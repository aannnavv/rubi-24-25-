# Функція для перевірки, чи є символ оператором
# Перевіряємо, чи символ входить до списку доступних операторів
def operator?(char)
  ['+', '-', '*', '/'].include?(char)
end

# Функція для визначення пріоритету операторів
# Повертає відповідний рівень пріоритету для кожного оператора
def precedence(operator)
  case operator
  when '+', '-' # Оператори додавання та віднімання мають найменший пріоритет
    1
  when '*', '/' # Оператори множення та ділення мають вищий пріоритет
    2
  else # Для невідомих символів повертається нульовий пріоритет
    0
  end
end

# Основна функція для перетворення інфіксного виразу в зворотній польський запис (RPN)
def to_rpn(expression)
  output = [] # Масив для збереження результату у вигляді RPN
  operators = [] # Стек для операторів

  # Розбиваємо вхідний вираз на токени (числа або оператори) за пробілами
  tokens = expression.split

  tokens.each do |token|
    if token =~ /^\d+$/ # Перевіряємо, чи токен є числом (регулярний вираз для цифр)
      output << token # Додаємо число до вихідного масиву
    elsif operator?(token) # Якщо токен є оператором
      # Поки стек операторів не порожній і пріоритет останнього оператора у стеці
      # більший або дорівнює пріоритету поточного оператора
      while operators.any? && precedence(operators.last) >= precedence(token)
        output << operators.pop # Переносимо оператор зі стеку до вихідного масиву
      end
      operators << token # Додаємо поточний оператор до стеку
    end
  end

  # Додаємо залишкові оператори зі стеку до вихідного масиву
  output.concat(operators.reverse)

  # Об'єднуємо результат у рядок з пробілами між токенами
  output.join(' ')
end

# Отримуємо математичний вираз від користувача
print "Введіть математичний вираз (наприклад, '3 + 4 * 2'): "
input_expression = gets.chomp # Зчитуємо введений рядок від користувача

# Викликаємо функцію для перетворення у RPN і зберігаємо результат
rpn_output = to_rpn(input_expression)

# Виводимо результат у вигляді зворотного польського запису
puts "RPN: #{rpn_output}"
